\documentclass{article}
\pagestyle{empty}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage{hyperref}

%% Ideally, I should make this into a file.
%% But I don't remember how to include the file :-)
\newcommand{\OR}{ \vee }
\newcommand{\AND}{ \wedge }
\newcommand{\IMPL}{ \rightarrow }
\newcommand{\EQUIV}{ \leftrightarrow }
\newcommand{\LOGEQ}{<\equiv> }
\newcommand{\NOT}{\widetilde{}\enspace}
\newcommand{\lam}{\lambda}

\begin{document}

%{\large\bf Work in pairs}



\begin{center}
{\large\bf Introduction to the $\lam$-calculus for CSci 4651}
\\ 
{\large\bf Elena Machkasova, UMN Morris}
\end{center}

\section{Overview}
\textit{The Lambda Calculus ($\lam$-calculus)} was developed by an American mathematician Alonzo Church in 1930s to study computation. 
It uses anonymous functions and their composition to represent computation. The $\lam$-calculus has been proven equivalent to 
the Turning Machine model of computation (invented by Alan Turing in 1936) which includes an infinite tape (modeling computer memory) and a collection of states of the computing device that perform different actions (modeling a program). 

The $\lam$-calculus and its more modern variants and extensions is used to formally define evaluation of a program, and 
specifically different orders of evaluation, including \textit{call-by-value} and \textit{call-by-name} evaluation strategies that we cover below, 
as well as \textit{call-by-need} that represents \href{https://en.wikipedia.org/wiki/Lazy_evaluation}{lazy evaluation strategy}, 
\href{https://en.wikipedia.org/wiki/\%CE\%A0-calculus}{\textit{$\pi$-calculus (pi-calculus)}} that represents a distributed system of processes communicating via channels, and many other. 

\section{Syntax}

$\lam$-calculus operates with expressions known as $\lam$-terms that we define below. 
Even though the classical $\lam$-calculus doesn't directly include numbers, it is possible to define $\lam$-terms 
that correspond to numbers and define
arithmetic operations on them. For simplicity we include integer constants directly into expressions in the examples. 

The syntax of the $\lam$-calculus is given by a BNF-like notation. Expressions in the $\lam$-calculus are called \textit{terms}, 
and a term is recursively defined as follows:
$$
M ::= x \mid c \mid \lam x. M \mid M_1 M_2,
$$
which means that a term $M$ is either a variable (represented by $x$, but other lower-case letters can be used, such as $y,z,u$, etc.), a constant (a number or a boolean or another type, as needed), or $\lam x. M$, where $M$ is a term, or an application of one term to another, denoted $M_1 M_2$. Capital letters, in particular $N, P, Q$, are also used to denote terms. 

$\lam x. M$ represents an anonymous single-parameter function with the parameter $x$ and the body $M$. For example, $\lam x. x$ is the identity function that takes a parameter $x$ and returns it unchanged. There is no way to represent a function with more than one parameters, but you can always ``feed'' the parameters separately, one by one: $\lam x. \lam y. M$ (an approach known as ``currying'').

$M_1 M_2$ stands for applying the term $M_1$ (as  a function) to $M_2$. For example, $(\lam x. x) 5$ stands for applying the identity function to a constant $5$. Note that the scope of the lambda extends as far to the right as possible, so parentheses are needed here since without the parentheses   $\lam x. x~5$ would stand for a function that takes $x$ and returns the result of applying it to $5$. Application is left-associative, so $M_1 M_2M_3$ stands for $(M_1 M_2)M_3$. 

In addition to the operations given in the BNF above I will use arithmetic operations in examples. For instance, $\lam x. x + 5$ represents a function that takes $x$ and returns $x + 5$. 

\section{$\alpha$-equivalence}
Just like a function may use local and global variables, a lambda term may have \textit{bound} and \textit{free} variables. For example, in $\lam x.  x + y$ the variable $x$ is bound by the lambda, and $y$ is free. 

Note that if we wrap this term into a lambda binding $y$, then both $x$ and $y$ will be bound, although by different lambdas: $\lam y. \lam x.  x + y$. 

Also observe that if we wrap $\lam x.  x + y$ into another lambda binding $x$, we get the term $\lam x. \lam x.  x + y$ in which $y$ is still free, and $x$ is still bound by the inner lambda. The outer lambda is not using its argument. This means that its name can be anything (other than $y$), and the term will behave in exactly the same way, for example $\lam z. \lam x.  x + y$.

Two terms $M$ and $N$ are called \textit{$\alpha$-equivalent} if they are equivalent to each other up to consistent renaming of the bound variables. For instance, $\lam x. \lam x.  x + y$ is $\alpha$-equivalent to $\lam z. \lam x.  x + y$, but not to 
$\lam y. \lam x.  x + y$. We say that adding $\lam y$  to $\lam x.  x + y$ \textit{captures} the free variable $y$. 

$\alpha$-equivalence is the same notion as a consistent renaming of local variables in a function or a method in a program or variables in expressions with $\forall$ and $\exists$ quantifiers in predicate calculus. As such, it is a familiar concept, and we omit the formal definition. 

\section{$\beta$-reduction}
The $\lam$-calculus describes computations in a functional language, so its main operation is a function application, i.e. applying one term to another. This operation is known as \textit{$\beta$-reduction}. There are two main variations of the $\beta$-reduction: \textit{call-by-name}, often abbreviated CBN, and \textit{call-by-value} (CBV). Since this is the main operation that affects the entire system, we distinguish between the CBN $\lam$-calculus and CBV $\lam$-calculus. 

In both cases of the calculi the goal of $\beta$-reduction is to \textit{evaluate} a given term to a \textit{value}, i.e. the final result, or the point where no more evaluation is possible. 
Strictly speaking, not all final results are values - for example, a computation may end up at an error, like $2 \lam x. x$ (here $2$ is applied to $\lam x. x$, but $2$ is not a function, and therefore cannot be applied, so there is no way to evaluate this term any further). A more general term for the result of a computation that can't be evaluated any further is a \textit{normal form}, and values are ``good'' normal forms. 
We define a value formally in section~\ref{cbv}. 

Note that in our examples in addition to $\beta$-reduction we are allowed to perform arithmetic operations, such as evaluate $2 + 3$ to $5$. Such operations are allowed in both calculi and work the same way. 

$\beta$-reduction is used for two purposes: as an \textit{evaluation strategy} that defines how a program will be evaluated on the computer, and as an \textit{optimization}, typically thought of as being performed at compilation time to speed up the program. The distinction between the two is that \textit{evaluation strategy} is deterministic: given a term that needs to be evaluated, it will perform steps in a particular order to reach the result. $\beta$-reduction as an optimization, however, could be performed anywhere in a term at any point in a hope of simplifying the term and avoiding more work later. When we study $\beta$-reduction as an optimization, we are concerned with its \textit{correctness}: is it possible that some operations that it performs change the result of evaluation? We discuss these issues more in section~\ref{eval}.

\subsection{CBN $\lam$-calculus}\label{cbn}

\subsection{CBV $\lam$-calculus}\label{cbv}

\subsection{Evaluation vs optimization}\label{eval}

\subsection{Confluence}

\end{document}
